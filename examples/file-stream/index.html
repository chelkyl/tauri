<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Tauri</title>
  </head>

  <body>
    <h1>Tauri File Streaming</h1>
    <div>
      <label for="base-directory">Base file directory</label>
      <select id="base-directory-select" name="base-directory"></select>
    </div>
    <div class="grid">
      <div>
        <label for="write-filepath">Filepath:</label>
        <input id="write-filepath-input" name="write-filepath">
        <button id="write-filepath-open">Open write stream</button>
        <div id="write-filepath-open-result"></div>
        <br>
        <textarea id="write-content-input"></textarea>
        <button id="write-content">Write</button>
        <div id="write-content-result"></div>
      </div>
      <div>
        <label for="read-filepath">Filepath:</label>
        <input id="read-filepath-input" name="read-filepath">
        <button id="read-filepath-open">Open read stream</button>
        <div id="read-filepath-open-result"></div>
        <br>
        <button id="read-content">Read chunk</button>
        <button id="clear-read-content">Clear read chunks</button>
        <div id="read-content-result"></div>
      </div>
    </div>
    <script>
      const { ReadFileStream, WriteFileStream, BaseDirectory } = window.__TAURI__.fs

      /**
       * @typedef {object} ReadFileStream
       * @property {string} filepath
       * @property {number} fd
       * @property {boolean} closed
       * @property {(options: FsOptions) => Promise<ReadFileStream>} open
       * @property {() => Promise<void>} close
       * @property {(onData: (data: Uint8Array) => void) => Promise<void>} read
       */

      /**
       * @typedef {object} WriteFileStream
       * @property {string} filepath
       * @property {number} fd
       * @property {boolean} closed
       * @property {(options: FsOptions) => Promise<ReadFileStream>} open
       * @property {() => Promise<void>} close
       * @property {(data: string | Uint8Array) => Promise<void>} write
       */

       /** @type {ReadFileStream} */
      let readFilestream
      /** @type {WriteFileStream} */
      let writeFilestream

      /** @type {HTMLSelectElement} */
      const baseDirectorySelect = document.querySelector('#base-directory-select')

      /** @type {HTMLInputElement} */
      const writeFilepathInput = document.querySelector('#write-filepath-input')
      /** @type {HTMLButtonElement} */
      const writeOpenButton = document.querySelector('#write-filepath-open')
      /** @type {HTMLDivElement} */
      const writeOpenResult = document.querySelector('#write-filepath-open-result')

      /** @type {HTMLButtonElement} */
      const writeButton = document.querySelector('#write-content')
      /** @type {HTMLInputElement} */
      const writeInput = document.querySelector('#write-content-input')
      /** @type {HTMLDivElement} */
      const writeResult = document.querySelector('#write-content-result')

      /** @type {HTMLInputElement} */
      const readFilepathInput = document.querySelector('#read-filepath-input')
      /** @type {HTMLButtonElement} */
      const readOpenButton = document.querySelector('#read-filepath-open')
      /** @type {HTMLDivElement} */
      const readOpenResult = document.querySelector('#read-filepath-open-result')

      /** @type {HTMLButtonElement} */
      const readButton = document.querySelector('#read-content')
      /** @type {HTMLButtonElement} */
      const clearReadButton = document.querySelector('#clear-read-content')
      /** @type {HTMLDivElement} */
      const readResult = document.querySelector('#read-content-result')

      /** @type {HTMLDivElement} */
      const gridContainer = document.querySelector('.grid')
      gridContainer.style.display = 'grid'
      gridContainer.style.gridTemplateColumns = 'repeat(auto-fit, minmax(300px, auto))'

      /**
       * @param {ReadFileStream|WriteFileStream} cls
       * @param {HTMLInputElement} filepathInput
       * @param {HTMLDivElement} resultElement
       */
      async function openStream(cls, filepathInput, resultElement) {
        /** @type {ReadFileStream|WriteFileStream} */
        const filestream = new cls(filepathInput.value)
        resultElement.innerText = ''
        try {
          await filestream.open({dir: BaseDirectory[baseDirectorySelect.value]})
          resultElement.innerText = 'Opened successfully'
        } catch (error) {
          resultElement.innerText = `${error}`
        }
        return filestream
      }

      async function writeToStream() {
        writeResult.innerText = ''
        if (!writeFilestream) {
          writeResult.innerText = 'Filestream is not open!'
          return
        }
        try {
          await writeFilestream.write(writeInput.value)
          writeResult.innerText = 'Success'
          writeInput.value = ''
        } catch (error) {
          writeResult.innerText = `Error: ${error}`
        }
      }

      async function readFromStream() {
        if (!readFilestream) {
          readResult.innerText = 'Filestream is not open!'
          return
        }
        try {
          await readFilestream.read((data) => {
            const textElement = document.createElement('p')
            textElement.innerText = String.fromCharCode.apply(String, data)
            readResult.appendChild(textElement)
          })
        } catch (error) {
          const textElement = document.createElement('p')
          textElement.innerText = `Error: ${error}`
          readResult.appendChild(textElement)
        }
      }

      function clearReadContent(e) {
        while (readResult.firstChild) {
          readResult.removeChild(readResult.firstChild);
        }
      }

      const allowedBaseDirectories = [
        BaseDirectory.Data,
        BaseDirectory.Temp,
      ]

      for (const baseDirId of allowedBaseDirectories) {
        const option = document.createElement('option')
        option.label = BaseDirectory[baseDirId]
        option.value = BaseDirectory[baseDirId]
        baseDirectorySelect.appendChild(option)
      }
      baseDirectorySelect.firstChild.selected = true

      const openWriteStream = async () => writeFilestream = await openStream(WriteFileStream, writeFilepathInput, writeOpenResult)
      writeFilepathInput.addEventListener('keyup', async (e) => {
        /** @type {KeyboardEvent} */
        const evt = e
        if (evt.key == "Enter") {
          await openWriteStream()
        }
      })
      writeOpenButton.addEventListener('click', openWriteStream)

      const openReadStream = async () => readFilestream = await openStream(ReadFileStream, readFilepathInput, readOpenResult)
      readFilepathInput.addEventListener('keyup', async (e) => {
        /** @type {KeyboardEvent} */
        const evt = e
        if (evt.key == "Enter") {
          await openReadStream()
        }
      })
      readOpenButton.addEventListener('click', openReadStream)

      writeInput.addEventListener('keyup', async (e) => {
        /** @type {KeyboardEvent} */
        const evt = e
        if (evt.key == "Enter" && !evt.shiftKey) {
          await writeToStream()
        }
      })
      writeButton.addEventListener('click', writeToStream)

      readButton.addEventListener('click', readFromStream)

      clearReadButton.addEventListener('click', clearReadContent)
    </script>
  </body>
</html>
